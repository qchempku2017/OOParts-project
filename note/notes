1，今后使用任何外源性库编写程序的时候，请尽量链接动态库，少使用静态库。因为有时候外源库编译的时候也可能用动态库链接方式；把这种需要链接动态库才能发挥作用的静态库链接进你的主程序，你的主程序能顺利调用静态库里面的库函数，但是不知道去哪里找静态库需要的那个动态库。比如本工程中，scf.cpp能正常链接libcint.a，但是访问其中的库函数的时候，会出现找不到BLAS库函数dgemm_实现方法的问题。有动态库就用动态库，动态库因为是二进制机器语言文件，所以很容易跨语言移植。养成用动态库的良好习惯。新装了外源性库以后，记得把动态库的位置写道LD_LIBRARY_PATH变量里面去。
编译时链接动态库的语法是 -L/somepath/ -lname，大写L后面不加空格紧跟动态库所在文件夹；小写l后面紧跟动态库文件名简写，简写的方法是把文件名开头的lib三个字母以及文件名后缀去掉。

2，使用外源性库的时候，请尽量不要把库里面的头文件、动静态库文件拿出来放到你的主程序源代码main.cpp的文件夹下面！这样在头文件有多重inculde的情况下，头文件很有可能跟丢。比如本工程中，我们把cint.h与scf.cpp放在同一个文件夹下编译，编译器可以找到cint.h，但是并不能识别cint.h里面include的<complex.h>是什么东西，即使我们在scf.cpp里面写了extern"C"{#include "cint.h"}也没用，g++不会按gcc的搜索目录去查找complex.h。使用外源库时，最好还是不要去复制安装目录里面的东西，把头文件路径写全就行。
对了，用extern“C”的情况下，cint.h中include “complex.h”最好也把路径写全，写成include “/usr/include/complex.h”，因为还是那个问题，g++不会查找gcc的默认搜索路径。

3，外源性库的头文件有时候不会把所有库函数声明出来，但是动态库里面却有所有库函数的实现。这时候我们可以按照说明书，在自己的主程序里面写需要用的库函数的声明（即写一个接口），然后调用就可以了。
问：动态库是二进制文件，它里面应该是没有函数名称的信息的；它是怎么知道你定义的接口对应于哪一个库函数的呢？事实上动态库里面有一个函数表部分，其中记录了函数名称信息，可以与你的声明对的上。

4,问：做了一个实验：如果只在scf.cpp里面写cint_ovlp_cart函数的接口，不在cint.h里面写；或者不引用cint.h，既算链接了动态库，都会导致函数未定义。好像要读取libcint.so必须通过cint.h。这是为什么？
这是因为编译器只会以.h为入口检索动态库吗？

5，intel mkl里面的矩阵是行主序的，我们拿到的libcint矩阵却是列主序的，一定要小心！

